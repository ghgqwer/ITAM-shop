import { CastableBase, ReadonlyArray, ReadonlyPath, append, defineProperties, stringifyPath } from "@ark/util";
import { arkKind } from "./utils.js";
export class ArkError extends CastableBase {
    [arkKind] = "error";
    path;
    data;
    nodeConfig;
    input;
    constructor(input, ctx) {
        super();
        this.input = input;
        defineProperties(this, input);
        const data = ctx.data;
        if (input.code === "union") {
            // flatten union errors to avoid repeating context like "foo must be foo must be"...
            input.errors = input.errors.flatMap(e => e.hasCode("union") ? e.errors : e);
        }
        this.nodeConfig = ctx.config[this.code];
        this.path =
            input.relativePath ? new ReadonlyPath(...ctx.path, ...input.relativePath)
                : input.path ? new ReadonlyPath(...input.path)
                    : new ReadonlyPath(...ctx.path);
        this.data = "data" in input ? input.data : data;
    }
    hasCode(code) {
        return this.code === code;
    }
    get propString() {
        return stringifyPath(this.path);
    }
    get expected() {
        return (this.input.expected ?? this.nodeConfig.expected?.(this.input));
    }
    get actual() {
        return this.input.actual ?? this.nodeConfig.actual?.(this.data);
    }
    get problem() {
        return this.input.problem ?? this.nodeConfig.problem(this);
    }
    get message() {
        return this.input.message ?? this.nodeConfig.message(this);
    }
    toString() {
        return this.message;
    }
    throw() {
        throw this;
    }
}
export class ArkErrors extends ReadonlyArray {
    ctx;
    constructor(ctx) {
        super();
        this.ctx = ctx;
    }
    byPath = Object.create(null);
    byAncestorPath = Object.create(null);
    count = 0;
    mutable = this;
    add(error) {
        if (this.includes(error))
            return;
        this._add(error);
    }
    affectsPath(path) {
        if (this.length === 0)
            return false;
        return (
        // this would occur if there is an existing error at a prefix of path
        // e.g. the path is ["foo", "bar"] and there is an error at ["foo"]
        path.stringifyAncestors().some(s => s in this.byPath) ||
            // this would occur if there is an existing error at a suffix of path
            // e.g. the path is ["foo"] and there is an error at ["foo", "bar"]
            path.stringify() in this.byAncestorPath);
    }
    _add(error) {
        const existing = this.byPath[error.propString];
        if (existing) {
            const errorIntersection = new ArkError({
                code: "intersection",
                errors: existing.hasCode("intersection") ?
                    [...existing.errors, error]
                    : [existing, error]
            }, this.ctx);
            const existingIndex = this.indexOf(existing);
            this.mutable[existingIndex === -1 ? this.length : existingIndex] =
                errorIntersection;
            this.byPath[error.propString] = errorIntersection;
            // add the original error here rather than the intersection
            // since the intersection is reflected by the array of errors at
            // this path
            this.addAncestorPaths(error);
        }
        else {
            this.byPath[error.propString] = error;
            this.addAncestorPaths(error);
            this.mutable.push(error);
        }
        this.count++;
    }
    addAncestorPaths(error) {
        error.path.stringifyAncestors().forEach(propString => {
            this.byAncestorPath[propString] = append(this.byAncestorPath[propString], error);
        });
    }
    merge(errors) {
        errors.forEach(e => {
            if (this.includes(e))
                return;
            this._add(new ArkError({ ...e, path: [...this.ctx.path, ...e.path] }, this.ctx));
        });
    }
    get summary() {
        return this.toString();
    }
    get message() {
        return this.toString();
    }
    get issues() {
        return this;
    }
    toString() {
        return this.join("\n");
    }
    throw() {
        throw new AggregateError(this, this.message);
    }
}
