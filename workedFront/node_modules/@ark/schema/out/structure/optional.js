import { hasDomain, omit, printable, throwParseError, unset } from "@ark/util";
import { ArkErrors } from "../shared/errors.js";
import { implementNode } from "../shared/implement.js";
import { registeredReference } from "../shared/registry.js";
import { traverseKey } from "../shared/traversal.js";
import { BaseProp, intersectProps } from "./prop.js";
const implementation = implementNode({
    kind: "optional",
    hasAssociatedError: false,
    intersectionIsOpen: true,
    keys: {
        key: {},
        value: {
            child: true,
            parse: (schema, ctx) => ctx.$.parseSchema(schema)
        },
        default: {
            preserveUndefined: true
        }
    },
    // safe to spread here as a node will never be passed to normalize
    normalize: ({ ...schema }, $) => {
        const value = $.parseSchema(schema.value);
        schema.value = value;
        if (value.defaultMeta !== unset)
            schema.default ??= value.defaultMeta;
        return schema;
    },
    defaults: {
        description: node => `${node.compiledKey}?: ${node.value.description}`
    },
    intersections: {
        optional: intersectProps
    }
});
export class OptionalNode extends BaseProp {
    constructor(...args) {
        super(...args);
        if ("default" in this.inner) {
            assertDefaultValueAssignability(this.value, this.inner.default, this.serializedKey);
        }
    }
    get outProp() {
        if (!this.hasDefault())
            return this;
        const { default: defaultValue, ...requiredInner } = this.inner;
        requiredInner.value = requiredInner.value.withMeta(meta => omit(meta, optionalValueMetaKeys));
        return this.cacheGetter("outProp", this.$.node("required", requiredInner, { prereduced: true }));
    }
    expression = `${this.compiledKey}?: ${this.value.expression}${this.hasDefault() ? ` = ${printable(this.inner.default)}` : ""}`;
    defaultValueMorphs = this.computeDefaultValueMorphs();
    defaultValueMorphsReference = registeredReference(this.defaultValueMorphs);
    computeDefaultValueMorphs() {
        if (!this.hasDefault())
            return [];
        const defaultInput = this.default;
        if (typeof defaultInput === "function") {
            return [
                // if the value has a morph, pipe context through it
                this.value.includesMorph ?
                    (data, ctx) => {
                        traverseKey(this.key, () => this.value((data[this.key] = defaultInput()), ctx), ctx);
                        return data;
                    }
                    : data => {
                        data[this.key] = defaultInput();
                        return data;
                    }
            ];
        }
        // non-functional defaults can be safely cached as long as the morph is
        // guaranteed to be pure and the output is primitive
        const precomputedMorphedDefault = this.value.includesMorph ? this.value.assert(defaultInput) : defaultInput;
        return [
            hasDomain(precomputedMorphedDefault, "object") ?
                // the type signature only allows this if the value was morphed
                (data, ctx) => {
                    traverseKey(this.key, () => this.value((data[this.key] = defaultInput), ctx), ctx);
                    return data;
                }
                : data => {
                    data[this.key] = precomputedMorphedDefault;
                    return data;
                }
        ];
    }
}
export const Optional = {
    implementation,
    Node: OptionalNode
};
const optionalValueMetaKeys = {
    default: 1,
    optional: 1
};
export const assertDefaultValueAssignability = (node, value, key = "") => {
    if (hasDomain(value, "object") && typeof value !== "function")
        throwParseError(writeNonPrimitiveNonFunctionDefaultValueMessage(key));
    const out = node.in(typeof value === "function" ? value() : value);
    if (out instanceof ArkErrors)
        throwParseError(writeUnassignableDefaultValueMessage(out.message, key));
    return value;
};
export const writeUnassignableDefaultValueMessage = (message, key = "") => `Default value${key && ` for key ${key}`} is not assignable: ${message}`;
export const writeNonPrimitiveNonFunctionDefaultValueMessage = (key) => `Default value${key && ` for key ${key}`} is not primitive so it should be specified as a function like () => ({my: 'object'})`;
