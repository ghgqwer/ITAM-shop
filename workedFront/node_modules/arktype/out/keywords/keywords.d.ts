import type { ArkErrors, arkKind } from "@ark/schema";
import type { inferred } from "@ark/util";
import type { distill } from "../attributes.ts";
import type { GenericParser } from "../generic.ts";
import type { BaseType } from "../methods/base.ts";
import type { BoundModule, Module } from "../module.ts";
import type { inferDefinition, validateDefinition } from "../parser/definition.ts";
import { type bindThis, type Scope } from "../scope.ts";
import type { DeclarationParser, DefinitionParser, SchemaParser, Type, TypeParser } from "../type.ts";
import { arkBuiltins } from "./builtins.ts";
import { arkPrototypes } from "./constructors/constructors.ts";
import { number } from "./number/number.ts";
import { string } from "./string/string.ts";
import { arkTsGenerics, arkTsKeywords, object, unknown } from "./ts.ts";
export interface Ark extends Omit<Ark.keywords, keyof Ark.wrapped>, Ark.wrapped {
}
export declare namespace Ark {
    interface keywords extends arkTsKeywords.$, arkTsGenerics.$, arkPrototypes.keywords, arkBuiltins.$ {
    }
    interface wrapped extends arkPrototypes.wrapped {
        string: string.submodule;
        number: number.submodule;
        object: object.submodule;
        unknown: unknown.submodule;
    }
    interface typeAttachments extends arkTsKeywords.$ {
        Key: arkBuiltins.$["Key"];
        Record: arkTsGenerics.$["Record"];
        Date: arkPrototypes.$["Date"];
        Array: arkPrototypes.$["Array"]["root"];
    }
    interface boundTypeAttachments<$> extends Omit<BoundModule<typeAttachments, $>, arkKind> {
    }
}
export declare const ark: Scope<Ark>;
export declare const keywords: Module<Ark>;
export declare const type: TypeParser<{}>;
export declare namespace type {
    interface cast<to> {
        [inferred]?: to;
    }
    type errors = ArkErrors;
    /** @ts-ignore cast variance */
    interface Any<out t = any> extends BaseType<t, any> {
    }
    type infer<def, $ = {}, args = bindThis<def>> = inferDefinition<def, $, args>;
    namespace infer {
        type In<def, $ = {}, args = {}> = distill.In<inferDefinition<def, $, args>>;
        type Out<def, $ = {}, args = {}> = distill.Out<inferDefinition<def, $, args>>;
        namespace withAttributes {
            type In<def, $ = {}, args = {}> = distill.withAttributes.In<inferDefinition<def, $, args>>;
            type Out<def, $ = {}, args = {}> = distill.withAttributes.Out<inferDefinition<def, $, args>>;
        }
        namespace introspectable {
            type Out<def, $ = {}, args = {}> = distill.introspectable.Out<inferDefinition<def, $, args>>;
        }
    }
    type validate<def, $ = {}, args = bindThis<def>> = validateDefinition<def, $, args>;
}
export type type<t = unknown, $ = {}> = Type<t, $>;
export declare const generic: GenericParser<{}>;
export declare const schema: SchemaParser<{}>;
export declare const define: DefinitionParser<{}>;
export declare const declare: DeclarationParser<{}>;
